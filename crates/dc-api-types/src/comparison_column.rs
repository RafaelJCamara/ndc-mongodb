/*
 *
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document:
 *
 * Generated by: https://openapi-generator.tech
 */

use nonempty::NonEmpty;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ComparisonColumn {
    #[serde(rename = "column_type")]
    pub column_type: String,
    /// The name of the column
    #[serde(rename = "name")]
    pub name: ColumnSelector,
    /// The path to the table that contains the specified column. Missing or empty array means the current table. [\"$\"] means the query table. No other values are supported at this time.
    #[serde(rename = "path", skip_serializing_if = "Option::is_none")]
    // TODO: OpenAPI has a default value here. Should we remove the optional?
    pub path: Option<Vec<String>>,
}

impl ComparisonColumn {
    pub fn new(column_type: String, name: ColumnSelector) -> ComparisonColumn {
        ComparisonColumn {
            column_type,
            name,
            path: None,
        }
    }
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ColumnSelector {
    Path(NonEmpty<String>),
    Column(String),
}

impl ColumnSelector {
    pub fn new(column: String) -> ColumnSelector {
        ColumnSelector::Column(column)
    }

    pub fn join(&self, separator: &str) -> String {
        match self {
            ColumnSelector::Path(p) => p
                .iter()
                .map(|s| s.as_str())
                .collect::<Vec<&str>>()
                .join(separator),
            ColumnSelector::Column(c) => c.clone(),
        }
    }

    pub fn as_var(&self) -> String {
        self.join("_")
    }

    pub fn as_path(&self) -> String {
        self.join(".")
    }

    pub fn is_column(&self) -> bool {
        match self {
            ColumnSelector::Path(_) => false,
            ColumnSelector::Column(_) => true,
        }
    }
}

#[cfg(test)]
mod test {
    use mongodb::bson::{bson, from_bson, to_bson};
    use nonempty::nonempty;

    use super::{ColumnSelector, ComparisonColumn};

    #[test]
    fn serialize_comparison_column() -> Result<(), anyhow::Error> {
        let input = ComparisonColumn {
            column_type: "string".to_owned(),
            name: ColumnSelector::new("title".to_owned()),
            path: None,
        };
        assert_eq!(
            to_bson(&input)?,
            bson!({"column_type": "string", "name": "title"})
        );
        Ok(())
    }

    #[test]
    fn parses_comparison_column() -> Result<(), anyhow::Error> {
        let input = bson!({"column_type": "string", "name": "title"});
        assert_eq!(
            from_bson::<ComparisonColumn>(input)?,
            ComparisonColumn {
                column_type: "string".to_owned(),
                name: ColumnSelector::new("title".to_owned()),
                path: None,
            }
        );
        Ok(())
    }

    #[test]
    fn serialize_column_selector() -> Result<(), anyhow::Error> {
        let input = ColumnSelector::Path(nonempty![
            "path".to_owned(),
            "to".to_owned(),
            "nested".to_owned(),
            "field".to_owned()
        ]);
        assert_eq!(to_bson(&input)?, bson!(["path", "to", "nested", "field"]));

        let input = ColumnSelector::new("singleton".to_owned());
        assert_eq!(to_bson(&input)?, bson!("singleton"));
        Ok(())
    }

    #[test]
    fn parse_column_selector() -> Result<(), anyhow::Error> {
        let input = bson!(["path", "to", "nested", "field"]);
        assert_eq!(
            from_bson::<ColumnSelector>(input)?,
            ColumnSelector::Path(nonempty![
                "path".to_owned(),
                "to".to_owned(),
                "nested".to_owned(),
                "field".to_owned()
            ])
        );

        let input = bson!("singleton");
        assert_eq!(
            from_bson::<ColumnSelector>(input)?,
            ColumnSelector::new("singleton".to_owned())
        );
        Ok(())
    }
}

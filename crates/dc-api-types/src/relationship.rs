/*
 *
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document:
 *
 * Generated by: https://openapi-generator.tech
 */

use std::{collections::HashMap, fmt};

use crate::comparison_column::ColumnSelector;
use crate::target::target_or_table_name;
use serde::{
    de::{self, Visitor},
    Deserialize, Deserializer, Serialize,
};

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Relationship {
    /// A mapping between columns on the source table to columns on the target table
    #[serde(rename = "column_mapping")]
    pub column_mapping: ColumnMapping,

    #[serde(rename = "relationship_type")]
    pub relationship_type: crate::RelationshipType,

    /// The target of the relationship.
    /// For backwards compatibility with previous versions of dc-api we allow the alternative property name "target_table" and allow table names to be parsed into Target::TTable
    #[serde(
        rename = "target",
        alias = "target_table",
        deserialize_with = "target_or_table_name"
    )]
    pub target: crate::Target,
}

#[derive(Clone, Debug, PartialEq)]
pub struct ColumnMapping(pub HashMap<ColumnSelector, ColumnSelector>);

impl Serialize for ColumnMapping {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        if self.0.keys().all(|k| k.is_column()) {
            return self.0.serialize(serializer);
        }
        self.0.iter().collect::<Vec<_>>().serialize(serializer)
    }
}

impl<'de> Deserialize<'de> for ColumnMapping {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        struct ColumnMappingVisitor;

        impl<'de> Visitor<'de> for ColumnMappingVisitor {
            type Value = ColumnMapping;

            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                formatter.write_str("Column mapping object or array")
            }

            fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
            where
                A: de::MapAccess<'de>,
            {
                let m: HashMap<String, ColumnSelector> =
                    Deserialize::deserialize(de::value::MapAccessDeserializer::new(map))?;
                Ok(ColumnMapping(
                    m.into_iter()
                        .map(|(k, v)| (ColumnSelector::new(k), v))
                        .collect(),
                ))
            }

            fn visit_seq<A>(self, seq: A) -> Result<Self::Value, A::Error>
            where
                A: de::SeqAccess<'de>,
            {
                let s: Vec<(ColumnSelector, ColumnSelector)> =
                    Deserialize::deserialize(de::value::SeqAccessDeserializer::new(seq))?;
                Ok(ColumnMapping(s.into_iter().collect()))
            }
        }
        deserializer.deserialize_any(ColumnMappingVisitor)
    }
}

impl Relationship {
    pub fn new(
        column_mapping: ColumnMapping,
        relationship_type: crate::RelationshipType,
        target: crate::Target,
    ) -> Relationship {
        Relationship {
            column_mapping,
            relationship_type,
            target,
        }
    }
}

#[cfg(test)]
mod test {
    use std::collections::HashMap;

    use mongodb::bson::{bson, from_bson, to_bson};
    use nonempty::nonempty;

    use crate::comparison_column::ColumnSelector;

    use super::ColumnMapping;

    #[test]
    fn serialize_column_mapping() -> Result<(), anyhow::Error> {
        let input = ColumnMapping(HashMap::from_iter(vec![(
            ColumnSelector::new("k".to_owned()),
            ColumnSelector::new("v".to_owned()),
        )]));
        assert_eq!(to_bson(&input)?, bson!({"k": "v"}));

        let input = ColumnMapping(HashMap::from_iter(vec![(
            ColumnSelector::Path(nonempty!["k".to_owned(), "j".to_owned()]),
            ColumnSelector::new("v".to_owned()),
        )]));
        assert_eq!(to_bson(&input)?, bson!([[["k", "j"], "v"]]));
        Ok(())
    }

    #[test]
    fn parse_column_mapping() -> Result<(), anyhow::Error> {
        let input = bson!({"k": "v"});
        assert_eq!(
            from_bson::<ColumnMapping>(input)?,
            ColumnMapping(HashMap::from_iter(vec![(
                ColumnSelector::new("k".to_owned()),
                ColumnSelector::new("v".to_owned())
            )]))
        );

        let input = bson!([[["k", "j"], "v"]]);
        assert_eq!(
            from_bson::<ColumnMapping>(input)?,
            ColumnMapping(HashMap::from_iter(vec![(
                ColumnSelector::Path(nonempty!["k".to_owned(), "j".to_owned()]),
                ColumnSelector::new("v".to_owned())
            )]))
        );
        Ok(())
    }
}

/*
 *
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document:
 *
 * Generated by: https://openapi-generator.tech
 */

use serde::{Deserialize, Serialize};

use crate::ArrayComparisonValue;

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum Expression {
    #[serde(rename = "and")]
    And {
        #[serde(rename = "expressions")]
        expressions: Vec<crate::Expression>,
    },
    #[serde(rename = "binary_arr_op")]
    ApplyBinaryArrayComparison {
        #[serde(rename = "column")]
        column: crate::ComparisonColumn,
        #[serde(rename = "operator")]
        operator: crate::BinaryArrayComparisonOperator,
        #[serde(rename = "value_type")]
        value_type: String,
        #[serde(rename = "values")]
        values: Vec<ArrayComparisonValue>,
    },
    #[serde(rename = "binary_op")]
    ApplyBinaryComparison {
        #[serde(rename = "column")]
        column: crate::ComparisonColumn,
        #[serde(rename = "operator")]
        operator: crate::BinaryComparisonOperator,
        #[serde(rename = "value")]
        value: crate::ComparisonValue,
    },
    #[serde(rename = "exists")]
    Exists {
        #[serde(rename = "in_table")]
        in_table: crate::ExistsInTable,
        #[serde(rename = "where")]
        r#where: Box<crate::Expression>,
    },
    #[serde(rename = "not")]
    Not {
        #[serde(rename = "expression")]
        expression: Box<crate::Expression>,
    },
    #[serde(rename = "or")]
    Or {
        #[serde(rename = "expressions")]
        expressions: Vec<crate::Expression>,
    },
    #[serde(rename = "unary_op")]
    ApplyUnaryComparison {
        #[serde(rename = "column")]
        column: crate::ComparisonColumn,
        #[serde(rename = "operator")]
        operator: crate::UnaryComparisonOperator,
    },
}

impl Expression {
    pub fn and(self, other: Expression) -> Expression {
        match other {
            Expression::And { mut expressions } => {
                expressions.push(self);
                Expression::And { expressions }
            }
            _ => Expression::And {
                expressions: vec![self, other],
            },
        }
    }
}

///
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum RHashType {
    #[serde(rename = "and")]
    And,
}

impl Default for RHashType {
    fn default() -> RHashType {
        Self::And
    }
}

#[cfg(test)]
mod test {
    use mongodb::bson::{bson, from_bson, to_bson};
    use pretty_assertions::assert_eq;

    use crate::{
        comparison_column::ColumnSelector, BinaryComparisonOperator, ComparisonColumn,
        ComparisonValue,
    };

    use super::Expression;

    #[test]
    fn serialize_apply_binary_comparison() -> Result<(), anyhow::Error> {
        let input = Expression::ApplyBinaryComparison {
            column: ComparisonColumn {
                column_type: "string".to_owned(),
                name: ColumnSelector::new("title".to_owned()),
                path: None,
            },
            operator: BinaryComparisonOperator::Equal,
            value: ComparisonValue::ScalarValueComparison {
                value: serde_json::json!("One"),
                value_type: "string".to_owned(),
            },
        };
        assert_eq!(
            to_bson(&input)?,
            bson!({
            "type": "binary_op",
            "column": {"column_type": "string", "name": "title"},
            "operator": "equal",
            "value": {"type": "scalar", "value": "One", "value_type": "string"}
            })
        );
        Ok(())
    }

    #[test]
    fn parses_apply_binary_comparison() -> Result<(), anyhow::Error> {
        let input = bson!({
            "type": "binary_op",
            "column": {"column_type": "string", "name": "title"},
            "operator": "equal",
            "value": {"type": "scalar", "value": "One", "value_type": "string"}
        });
        assert_eq!(
            from_bson::<Expression>(input)?,
            Expression::ApplyBinaryComparison {
                column: ComparisonColumn {
                    column_type: "string".to_owned(),
                    name: ColumnSelector::new("title".to_owned()),
                    path: None,
                },
                operator: BinaryComparisonOperator::Equal,
                value: ComparisonValue::ScalarValueComparison {
                    value: serde_json::json!("One"),
                    value_type: "string".to_owned(),
                },
            }
        );
        Ok(())
    }

    fn sample_expressions() -> (Expression, Expression, Expression) {
        (
            Expression::ApplyBinaryComparison {
                column: ComparisonColumn {
                    column_type: "int".to_owned(),
                    name: ColumnSelector::Column("age".to_owned()),
                    path: None,
                },
                operator: BinaryComparisonOperator::GreaterThan,
                value: ComparisonValue::ScalarValueComparison {
                    value: 25.into(),
                    value_type: "int".to_owned(),
                },
            },
            Expression::ApplyBinaryComparison {
                column: ComparisonColumn {
                    column_type: "string".to_owned(),
                    name: ColumnSelector::Column("location".to_owned()),
                    path: None,
                },
                operator: BinaryComparisonOperator::Equal,
                value: ComparisonValue::ScalarValueComparison {
                    value: "US".into(),
                    value_type: "string".to_owned(),
                },
            },
            Expression::ApplyBinaryComparison {
                column: ComparisonColumn {
                    column_type: "int".to_owned(),
                    name: ColumnSelector::Column("group_id".to_owned()),
                    path: None,
                },
                operator: BinaryComparisonOperator::Equal,
                value: ComparisonValue::ScalarValueComparison {
                    value: 4.into(),
                    value_type: "int".to_owned(),
                },
            },
        )
    }

    #[test]
    fn and_merges_with_existing_and_expression() {
        let (a, b, c) = sample_expressions();
        let other = Expression::And {
            expressions: vec![a.clone(), b.clone()],
        };
        let expected = Expression::And {
            expressions: vec![a, b, c.clone()],
        };
        let actual = c.and(other);
        assert_eq!(actual, expected);
    }

    #[test]
    fn and_combines_existing_expression_using_operator() {
        let (a, b, c) = sample_expressions();
        let other = Expression::Or {
            expressions: vec![a.clone(), b.clone()],
        };
        let expected = Expression::And {
            expressions: vec![
                c.clone(),
                Expression::Or {
                    expressions: vec![a, b],
                },
            ],
        };
        let actual = c.and(other);
        assert_eq!(actual, expected);
    }
}

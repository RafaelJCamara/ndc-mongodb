/*
 *
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document:
 *
 * Generated by: https://openapi-generator.tech
 */

use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ExistsInTable {
    #[serde(rename = "related")]
    RelatedTable {
        #[serde(rename = "relationship")]
        relationship: String,
    },
    #[serde(rename = "unrelated")]
    UnrelatedTable {
        /// The fully qualified name of a table, where the last item in the array is the table name and any earlier items represent the namespacing of the table name
        #[serde(rename = "table")]
        table: Vec<String>,
    },
}

///
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum RHashType {
    #[serde(rename = "related")]
    Related,
}

impl Default for RHashType {
    fn default() -> RHashType {
        Self::Related
    }
}

#[cfg(test)]
mod test {
    use mongodb::bson::{bson, from_bson, to_bson};

    use super::ExistsInTable;

    #[test]
    fn serialize_related_table() -> Result<(), anyhow::Error> {
        let input = ExistsInTable::RelatedTable {
            relationship: "foo".to_owned(),
        };
        assert_eq!(
            to_bson(&input)?,
            bson!({"type": "related", "relationship": "foo".to_owned()})
        );
        Ok(())
    }

    #[test]
    fn serialize_unrelated_table() -> Result<(), anyhow::Error> {
        let input = ExistsInTable::UnrelatedTable { table: vec![] };
        assert_eq!(to_bson(&input)?, bson!({"type": "unrelated", "table": []}));
        Ok(())
    }

    #[test]
    fn parses_related_table() -> Result<(), anyhow::Error> {
        let input = bson!({"type": "related", "relationship": "foo".to_owned()});
        assert_eq!(
            from_bson::<ExistsInTable>(input)?,
            ExistsInTable::RelatedTable {
                relationship: "foo".to_owned(),
            }
        );
        Ok(())
    }

    #[test]
    fn parses_unrelated_table() -> Result<(), anyhow::Error> {
        let input = bson!({"type": "unrelated", "table": []});
        assert_eq!(
            from_bson::<ExistsInTable>(input)?,
            ExistsInTable::UnrelatedTable { table: vec![] }
        );
        Ok(())
    }
}
